/*
  Arduino ROS node for JetsonCar project
  The Arduino controls a TRAXXAS Rally Car
  MIT License
  JetsonHacks (2016)
*/

/*
Modified to use with Teensy 3.2 
Runs a Traxxas Rally 2WD
ESC Tied to pin(10) 
Steering Servo tied to pin(9)
Runs everything using floating point cause why not
Changed to PWM write to writeMicroseconds for precision
Added a smoothing function to throttle to handle stray pulses and behave more like a car
Added Steering LEDs
Added framework for kill command from RF reciever tied to pin(2)
Future plans to move to Teensy 3.6 that has FPU
Future plans to implement brakes
*/

#if defined(ARDUINO) && ARDUINO >= 100
#include "Arduino.h"
#else
#include <WProgram.h>
#endif

#include <Servo.h>
#define USB_USBCON
#include <ros.h>
#include <std_msgs/UInt16.h>
#include <std_msgs/String.h>
#include <std_msgs/Int32.h>
#include <std_msgs/Empty.h>
#include <geometry_msgs/Twist.h>

ros::NodeHandle  nodeHandle;
// These are general bounds for the steering servo and the
// TRAXXAS Electronic Speed Controller (ESC)
const float minSteering = 1200 ;
const float maxSteering = 1800 ;
const float minThrottle = 0 ;
const float maxThrottle = 1680 ;
const float steeringIncrement = 9.0;
  float escCommand;
  float escThrottle;
  float smoothSteering = 1500;
  float diffGreat;
  float diffLess;

Servo steeringServo;
Servo electronicSpeedController ;  // The ESC on the TRAXXAS works like a Servo

std_msgs::Int32 str_msg;
ros::Publisher chatter("chatter", &str_msg);

// Arduino 'map' funtion for floating point
float fmap (float toMap, float in_min, float in_max, float out_min, float out_max) {
  return (toMap - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void driveCallback ( const geometry_msgs::Twist&  twistMsg )
{

  float steeringAngle = fmap(twistMsg.angular.z, 0.0, 1.0, minSteering, maxSteering) ;
  // The following could be useful for debugging
   //str_msg.data= steeringAngle ;
   //chatter.publish(&str_msg);
  // Check to make sure steeringAngle is within car range
  if (steeringAngle < minSteering) {
    steeringAngle = minSteering;
  }
  if (steeringAngle > maxSteering) {
    
    steeringAngle = maxSteering ;
  }

//   float diff = steeringAngle - smoothSteering;     //Future smoothing for steering
//   if (diff >= steeringIncrement){                  //currently solved with 60Hz refresh on callbacks from node
//    smoothSteering += steeringIncrement;
//   }
//   else if (diff <= -steeringIncrement) {
//    smoothSteering -= steeringIncrement;
//   }
//   else {
//    smoothSteering = steeringAngle;
//   }
   
  steeringServo.writeMicroseconds(steeringAngle) ;
  if(steeringAngle < 1450)
    digitalWrite(16, HIGH - digitalRead(16));  //blinks LED if turning left
  else if(steeringAngle> 1550)
    digitalWrite(15, HIGH - digitalRead(15));  //blinds LED if turning right
  else {
    digitalWrite(15,LOW);
    digitalWrite(16,LOW);
  }

  // ESC forward is between 0.5 and 1.0

  if (twistMsg.linear.x >= 0.5) {
    escCommand = (float)fmap(twistMsg.linear.x, 0.5, 1.0, 1500.0, maxThrottle) ;
  } else {
    //escCommand = (int)fmap(twistMsg.linear.x, 0.0, 1.0, 0.0, 1780.0) ;
    escCommand = (float)fmap(twistMsg.linear.x, 0.0, 0.5, 0.0, 1500.0) ;
  }
  // Check to make sure throttle command is within bounds
  if (escCommand < minThrottle) {
    escCommand = minThrottle;
  }
  if (escCommand > maxThrottle) {
    escCommand = maxThrottle ;
  }
  // The following could be useful for debugging
   //str_msg.data= escCommand ;
   //chatter.publish(&str_msg);
   
  escThrottle = escThrottle + 0.05*(escCommand-escThrottle);   //Exponential Smoothing ( ͡° ͜ʖ﻿ ͡°) for throttle
  

   
  electronicSpeedController.writeMicroseconds(escThrottle) ;
  digitalWrite(13, HIGH - digitalRead(13)); //toggle led
  


  
}

ros::Subscriber<geometry_msgs::Twist> driveSubscriber("/jetsoncar_teleop_joystick/cmd_vel", &driveCallback) ;

void setup() {
  pinMode(2, INPUT);
  pinMode(16, OUTPUT);
  pinMode(15, OUTPUT);
  pinMode(13, OUTPUT);
  Serial.begin(57600) ;
  nodeHandle.initNode();
  // This can be useful for debugging purposes
  nodeHandle.advertise(chatter);
  // Subscribe to the steering and throttle messages
  nodeHandle.subscribe(driveSubscriber) ;
  // Attach the servos to actual pins
  steeringServo.attach(9); // Steering servo is attached to pin 9
  electronicSpeedController.attach(10); // ESC is on pin 10
  // Initialize Steering and ESC setting
  // Steering centered is 90, throttle at neutral is 90
  steeringServo.writeMicroseconds(1500) ;
  //delay(10000);                                           //ESC Activation sequence
  //digitalWrite(13, HIGH - digitalRead(13));
  //electronicSpeedController.writeMicroseconds(1700);
  //delay(1000);
  //electronicSpeedController.writeMicroseconds(1300);
  //delay(1000);
  //electronicSpeedController.writeMicroseconds(1500);
  //delay(1000);
  

}

void loop() {
  nodeHandle.spinOnce();      //refreshes nodes
  delay(1);
    if(digitalRead(2)){       //future kill command
    delay(1);
    if(digitalRead(2)){       //flash left and right LEDs tied to pin 16,15 respectively
      for(int i=0;i<20;i++){
      digitalWrite(15,HIGH);
      digitalWrite(16,HIGH);
      delay(200);
      nodeHandle.spinOnce();
      digitalWrite(15,LOW);
      digitalWrite(16,LOW);
      delay(200);
      nodeHandle.spinOnce(); //
      }
    }
  }
}
